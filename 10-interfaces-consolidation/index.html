<!DOCTYPE html><html lang="en"><head>
    <meta charset="utf-8">
<title>Progettazione e Sviluppo del Software</title>
<meta name="description" content="Progettazione e Sviluppo del Software, Tecnologie dei Sistemi Informatici">
<meta name="author" content="Danilo Pianini">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="/reveal-js/dist/reset.css">
<link rel="stylesheet" href="/reveal-js/dist/reveal.css">
  <link rel="stylesheet" href="/css/custom-theme.min.993ae6c0a74b2209d9bdb352c2297beaeb28589fa50c62c12cad5d4287d66aae.css" id="theme"><link rel="stylesheet" href="/highlight-js/default.min.css">
    
<link rel="stylesheet" href="https://gitcdn.link/repo/DanySK/css-blur-animation/master/blur.css">
<link href="https://fonts.googleapis.com/css?family=Roboto Mono" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Oxygen Mono" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Ubuntu Mono" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css">

  </head>
  <body>
    
    <div class="reveal">
      <div class="slides">
  

    <section><h1 id="consolidamento-su-incapsulamento-e-interfacce">Consolidamento su incapsulamento e interfacce</h1>
<h4 id="progettazione-e-sviluppo-del-software">Progettazione e Sviluppo del Software</h4>
<h4 id="cdl-tecnologie-dei-sistemi-informatici">C.D.L. Tecnologie dei Sistemi Informatici</h4>
<h3 id="roberto-casadei-----robycasadeiuniboitmailtorobycasadeiuniboit"><a href="mailto:roby.casadei@unibo.it">Roberto Casadei — <code>roby.casadei@unibo.it</code></a></h3>
<h3 id="danilo-pianini-----danilopianiniuniboitmailtodanilopianiniuniboit"><a href="mailto:danilo.pianini@unibo.it">Danilo Pianini — <code>danilo.pianini@unibo.it</code></a></h3>
<p><a href="?print-pdf&amp;pdfSeparateFragments=false"><i class="fa fa-print" aria-hidden="true"></i> versione stampabile</a></p>
</section><section>
<h2 id="outline">Outline</h2>
<h3 id="goal-della-lezione">Goal della lezione</h3>
<ul>
<li>Riassumere i concetti, principi, meccanismi visti in precedenza</li>
<li>Mostrare alcune applicazioni notevoli (pattern) di questi concetti, principi, e meccanismi</li>
</ul>
<h3 id="argomenti">Argomenti</h3>
<ul>
<li>Introduzione ai <em>design pattern</em></li>
<li>Pattern <em>Strategy</em></li>
</ul>
</section><section>
<h2 id="riassunto-delle-puntate-precedenti">Riassunto delle puntate precedenti</h2>
<ul>
<li>Programma vs. sistema software</li>
<li>Fasi processo di sviluppo: analisi $\to$ design $\to$ implementazione $\to$ collaudo $\to$ deployment</li>
<li>Problem space (dominio/logica business) vs. solution space (scelte realizzative)
<ul>
<li>livello di astrazione</li>
</ul>
</li>
<li>Astrazione object-oriented
<ul>
<li><em>oggetto = stato + comportamento + identità</em> (cf. <em>incapsulamento</em>)</li>
<li>interazione attraverso “scambio di messaggi”</li>
<li><em>classe</em> come “tipo” di oggetti e come “template” di costruzione di oggetti simili (<em>istanze</em>)</li>
<li><em>interfaccia</em> vs. implementazione (cf. <em>information-hiding</em>)</li>
</ul>
</li>
<li>Riuso mediante
<ul>
<li>utilizzo di altri oggetti (<em>composizione</em>)</li>
<li>estensione dei servizi offerti da altri oggetti (<em>ereditarietà</em>)</li>
</ul>
</li>
</ul>
</section><section>
<ul>
<li>Java 17
<ul>
<li><em>write once, run everywhere</em></li>
<li>JDK: JRE (JVM [<code>java</code>] + JCL) + strumenti di sviluppo (<code>javac</code>, …)</li>
</ul>
</li>
<li>Costrutti Java per la OOP
<ul>
<li>tipi primitivi vs. tipi oggetto (classi)</li>
<li>variabili e riferimenti ad oggetti (allocati nello <em>heap</em>) (assegnamento per copia)</li>
<li>lifetime di oggetti va oltre lo scope; no deallocazione manuale (cf. <em>GC</em>)</li>
<li>classi: <em>campi</em> &amp; <em>metodi</em> (statici o d’istanza) – accedibili mediante <em>dot notation</em></li>
<li>concetto di <em>receiver</em> di una <em>method call</em> e variabile speciale <code>this</code></li>
<li><em>programmi</em>: metodo pubblico statico <code>main</code> in classe pubblica</li>
</ul>
</li>
<li>Strumenti: compilazione con <code>javac</code> ed esecuzione con <code>java</code></li>
</ul>
<p><em>Competenza attuale attesa: costruzione di semplici classi; loro esercizio mediante programmi; compilazione ed esecuzione di programmi</em></p>
</section><section>
<h1 id="design-pattern-e-progettazione-di-dettaglio">Design Pattern e Progettazione di Dettaglio</h1>
<h2 id="progettazione-di-dettaglio">Progettazione di dettaglio</h2>
<h3 id="elementi">Elementi</h3>
<ul>
<li>Non descrive ogni singola classe/interfaccia del sistema</li>
<li>Descrive relazioni fra oggetti, quelle ritenute più importanti per capire come il sistema è organizzato</li>
<li>Quelle che nascondono elementi non banali</li>
<li>Documentata da più diagrammi UML sempre di 5-10 classi ognuno</li>
</ul>
<h3 id="come-progettare-una-buona-classe-o-gruppo-di-classi">Come progettare una buona classe o gruppo di classi?</h3>
<ul>
<li>buona conoscenza della programmazione OO e delle linee guida di buona programmazione/progettazione note e discusse</li>
<li>utilizzo di cataloghi noti di pattern di progettazione (design pattern)</li>
</ul>
</section><section>
<h2 id="design-pattern">Design Pattern</h2>
<h3 id="i-pattern-di-progettazione">I Pattern di progettazione</h3>
<ul>
<li>Un <strong>pattern</strong> è una <em>soluzione notevole a problemi ricorrenti di design object-oriented</em>
 <!-- elementi riusabili (semplici ed eleganti) di progettazione OO -->
<ul>
<li>Idea: trasmettere esperienze (positive) e ore di lavoro (di identificazione, rifattorizzazione) ad altri per essere usate <em>tout court</em></li>
<li>Sono stati ottenuti in passato (e tuttora) dall’analisi di soluzioni ricorrenti in progetti diversi</li>
</ul>
</li>
<li>Alcuni sono particolarmente famosi, come quelli della <em>“Gang of Four”</em> (detti anche <em>Pattern GoF</em>)
<ul>
<li>Testo famosissimo (in C++): <em>Design Patterns: Elements of Reusable Object-Oriented Software</em> di <em>E. Gamma, R. Helm, R. Johnson, J. Vlissides</em></li>
<li>23 in tutto. Esempi: Decorator, Singleton, Template Method, Observer</li>
<li>(Cit. “SW di grosse dimensioni li usano praticamente tutti”)</li>
</ul>
</li>
<li>Benefici
<ul>
<li>Il loro uso migliora molto il codice</li>
<li>Ne favorisce la comprensione se li si indicano nella documentazione</li>
<li>Rende il codice più flessibile (nascono per questo)</li>
<li>Portano più direttamente ad una buona organizzazione</li>
</ul>
</li>
</ul>
</section><section>
<h2 id="design-pattern-in-questa-sede">Design Pattern in questa sede</h2>
<h3 id="nel-corso">Nel corso</h3>
<ul>
<li>Vari Pattern già stati utilizzati (es.: nelle librerie)</li>
<li>Vanno usati dove opportuno nel progetto d’esame (e nella relazione)</li>
<li>Possono essere tema dell’esame in laboratorio</li>
<li>Quelli visti a lezione sono da conoscere tassativamente</li>
</ul>
<h3 id="per-il-vostro-futuro">Per il vostro futuro</h3>
<ul>
<li>Noi porremo le basi per uno loro studio in autonomia</li>
<li>Un ottimo progettista li conosce e usa (ove opportuno) <em><strong>tutti</strong></em></li>
</ul>
</section><section>
<h2 id="motivazioni">Motivazioni</h2>
<h3 id="rifattorizzazione-refactoring">Rifattorizzazione (refactoring)</h3>
<ul>
<li>Operazione di modifica del codice che non aggiunge funzionalità</li>
<li>Ha lo scopo di migliorare programmazione e struttura del SW</li>
<li>Ha lo scopo di attrezzare il codice a possibili cambiamenti futuri</li>
<li>Può/deve quindi comportare una riprogettazione di alcune parti</li>
</ul>
<h3 id="la-necessità-del-refactoring">La necessità del refactoring</h3>
<ul>
<li>Una buona progettazione non la si ottiene al primo “colpo”, ma richiede vari refactoring</li>
<li>Brian Foote identifica tre fasi nello sviluppo di un sistem: prototyping, expansionary, consolidating; nel consolidamento si rifattorizza</li>
<li>Nell’agile programming, ogni ciclo di sviluppo non parte se non si è rifattorizzato il codice del ciclo precedente (sia in cicli corti che lunghi)</li>
</ul>
<h3 id="i-pattern">I pattern</h3>
<ul>
<li>L’esperienza pregressa risulta fondamentale per velocizzare il processo di rifattorizzazione</li>
<li>I Pattern di progettazione forniscono direttamente “ricette” di buona costruzione o rifattorizzazione del SW</li>
</ul>
</section><section>
<h2 id="struttura">Struttura</h2>
<h3 id="un-pattern-ha-quattro-elementi-fondamentali">Un Pattern ha quattro elementi fondamentali</h3>
<ul>
<li>Un nome. (È un aspetto fondamentale!)</li>
<li>Un problema che risolve. (La causa che porta al suo uso)</li>
<li>La soluzione che propone. (Gli elementi del progetto)</li>
<li>La conseguenza che porta. (Riuso, variabilità, performance,..)</li>
</ul>
<h3 id="granularità">Granularità</h3>
<ul>
<li>
<p>Gruppo ristretto di (1-5) oggetti/classi generali dipendenti fra loro</p>
</li>
<li>
<p>Sistemi più specifici o più complessi sono utili, ma non propriamente dei “Pattern”</p>
</li>
<li>
<p>Non singole classi riusabili (liste, hash-table)</p>
</li>
<li>
<p>Non “pattern architetturali” (come MVC)</p>
</li>
<li>
<p>Non framework complessi (gerarchia Swing, Reflection)</p>
</li>
</ul>
</section><section>
<h2 id="classificazione-dei-pattern-categorie">Classificazione dei Pattern: categorie</h2>
<h3 id="livello-proposito-del-pattern">Livello “proposito del Pattern”</h3>
<ul>
<li><em>Creazionali</em>: Riguardano la creazione degli oggetti</li>
<li><em>Strutturali</em>: Riguardano la composizione di classi/oggetti</li>
<li><em>Comportamentali</em>: Riguardano la interazione e distribuzione di responsabilità fra classi/oggetti</li>
</ul>
<h3 id="livello-scope">Livello “scope”</h3>
<ul>
<li>Classi: Il Pattern riguarda primariamente le relazioni fra classi (e sottoclassi), e quindi tratta aspetti statici (compile-time)</li>
<li>Oggetti: Il Pattern riguarda primariamente le relazioni fra oggetti (l’esistenza di riferimenti fra oggetti), e quindi tratta aspetti dinamici (run-time)</li>
</ul>
</section><section>
<h2 id="i-23-pattern-gof">I 23 Pattern GoF</h2>
<h3 id="creazionali">Creazionali</h3>
<ul>
<li>A livello di classe: <em><strong>Factory Method</strong></em></li>
<li>A livello di oggetto: <em><strong>Abstract Factory</strong></em>, <em><strong>Builder</strong></em>, Prototype, <em><strong>Singleton</strong></em></li>
</ul>
<h3 id="strutturali">Strutturali</h3>
<ul>
<li>A livello di classe: <em><strong>Adapter</strong></em></li>
<li>A livello di oggetto: <em><strong>Adapter</strong></em>, Bridge, Composite, <em><strong>Decorator</strong></em>, Facade, Proxy</li>
</ul>
<h3 id="comportamentali">Comportamentali</h3>
<ul>
<li>A livello di classe: Interpreter, <em><strong>Template Method</strong></em></li>
<li>A livello di oggetto: Chain of Responsibility, Command, <em><strong>Iterator</strong></em>, Mediator, Memento, Flyweight, <em><strong>Observer</strong></em>, State, <em><strong>Strategy</strong></em>, <em><strong>Visitor</strong></em></li>
</ul>
</section><section>
<h2 id="schema-di-descrizione-per-ogni-pattern">Schema di descrizione per ogni pattern</h2>
<p>Aderiremo al seguente schema, che è una semplificazione di quello proposto alla GoF</p>
<h3 id="ingredienti">Ingredienti</h3>
<ul>
<li>Descrizione in prosa (nome, motivazione, esempi, soluzione)</li>
<li>Rappresentazione grafica (diagramma delle classi generale)</li>
<li>Esempio (già visto/nuovo)</li>
</ul>
<h2 id="i-pattern-nel-corso">I pattern nel corso</h2>
<h3 id="esami-di-progetto">Esami di progetto</h3>
<ul>
<li>Identificarne/usarne “pochi” è considerato poco soddisfacente</li>
<li>Scegliere di usarli non è arbitario, ma è indice di buona progettazione e/o di buona rifattorizzazione</li>
<li>Gli argomenti: “in questo progetto non servivano” e “non c’è stato tempo” sono pessimi</li>
<li>Argomento di probabile discussione all’esame</li>
</ul>
<h3 id="di-conseguenza">Di conseguenza</h3>
<ul>
<li>I pattern qui presentati vanno conosciuti</li>
<li>Gli altri pattern sono facoltativi, e importanti per il vostro futuro</li>
</ul>
</section><section>
<h1 id="alcuni-pattern-iniziali">Alcuni pattern iniziali</h1>
<h2 id="singleton-creazionale-su-oggetti">Singleton: creazionale, su oggetti</h2>
<h3 id="intentomotivazione">Intento/motivazione</h3>
<pre><code>Garantire che una classe abbia una unica istanza, accessibile globalmente e facilmente a molteplici classi, senza doversi preoccupare di fornirne il riferimento a chi lo richiede (ad esempio passandolo al costruttore)
</code></pre>
<h3 id="esempi">Esempi</h3>
<ul>
<li>Un unico gestore di stampanti in un sistema</li>
<li>Un unico gestore del “log”</li>
<li><code>java.lang.Runtime</code></li>
</ul>
<h3 id="soluzione">Soluzione</h3>
<ul>
<li>La classe sia responsabile di tenere traccia di tale unica istanza</li>
<li>La classe impedisca la creazione di altri oggetti</li>
<li>La classe fornisca l’accesso a tale oggetto staticamente</li>
<li>Attenzione: singleton accoppia clienti e implementazione</li>
</ul>
</section><section>
<h2 id="singleton-uml">Singleton: UML</h2>
<p><img src="img/singleton.jpg" alt=""></p>
</section><section>
<h2 id="singleton-il-caso-di-javalangruntime">Singleton: Il caso di <code>java.lang.Runtime</code></h2>
<pre><code>\sizedrangedcode{\scriptsize}{3}{100}{\ecl/singleton/UseRuntime.java}
</code></pre>
</section><section>
<h2 id="singleton-il-caso-di-una-classe-log">Singleton: Il caso di una classe <code>Log</code></h2>
<pre><code>\sizedrangedcode{\scriptsize}{3}{100}{\ecl/singleton/Log.java}
\sizedrangedcode{\scriptsize}{3}{100}{\ecl/singleton/UseLog.java}
</code></pre>
</section><section>
<h2 id="singleton-conseguenze">Singleton: conseguenze</h2>
<h3 id="effetti-benefici">Effetti benefici</h3>
<ul>
<li>C’è un controllo “incapsulato” di chi vi accede</li>
<li>Evita di dover portare i riferimenti all’oggetto nei campi di tutti le classi che lo usano</li>
<li>È facile raffinare l’implementazione del singleton (via subclassing)</li>
<li>Può gestire la creazione by-need (detta anche <em>lazy</em>) dell’oggetto</li>
<li>Più flessibile dei metodi statici (che non hanno overriding)</li>
</ul>
<h3 id="critiche">Critiche</h3>
<ul>
<li>Il Singleton può essere problematico col multi-threading</li>
<li>Crea dipendenze nascoste, gli user dipendono dal nome della classe</li>
<li>Difficile tornare indietro dalla scelta di usare il singleton</li>
<li>Incapsula due responsabilità distinte (creazione + aspetti interni)</li>
<li>Rende meno estendibile il codice della classe (è meno “OOP”)</li>
<li>$\Rightarrow$ <em><strong>Da usare quando portare “in giro” il riferimento all’oggetto sarebbe complesso</strong></em></li>
</ul>
</section><section>
<h2 id="singleton-con-lazy-initialization-non-thread-safe">Singleton con “lazy initialization” (non thread-safe)</h2>
<pre><code>\sizedrangedcode{\scriptsize}{3}{100}{\ecl/singleton/LogLazy.java}
</code></pre>
</section><section>
<h2 id="singleton-con-lazy-initialization-e-thread-safe">Singleton con “lazy initialization” e “thread-safe”</h2>
<pre><code>\sizedrangedcode{\ssmall}{3}{100}{\ecl/singleton/LogLazyTS.java}
</code></pre>
</section><section>
<h2 id="template-method-comportamentale-su-classi">Template Method: comportamentale, su classi</h2>
<h3 id="intentomotivazione-1">Intento/motivazione</h3>
<pre><code>Definisce lo scheletro (template) di un algoritmo (o comportamento), lasciando l'indicazione di alcuni suoi aspetti alle sottoclassi.
</code></pre>
<h3 id="esempi-1">Esempi</h3>
<ul>
<li>In un input stream (<code>InputStream</code>), i vari metodi di lettura sono dei Template Method: dipendono dall’implementazione del solo concetto di lettura di un <code>int</code>
%*  Similmente, i metodi di <code>AbstractSet</code> tranne <code>size()</code> e <code>iterator()</code></li>
<li>Le interfacce funzionali con metodi di default che chiamano l’astratto</li>
</ul>
<h3 id="soluzione-1">Soluzione</h3>
<ul>
<li>L’algoritmo è realizzato attraverso un metodo non astratto (il template method) di una classe astratta</li>
<li>Questo realizza l’algoritmo, chiamando metodi astratti quando servono gli aspetti non noti a priori</li>
<li>Una sottoclasse fornisce l’implementazione dei metodi astratti</li>
</ul>
</section><section>
<h2 id="template-method-uml">Template Method: UML</h2>
<pre><code>![](img/template_method.jpg)
</code></pre>
</section><section>
<h2 id="template-method-una-estensione-di-inputstream">Template Method: Una estensione di <code>InputStream</code></h2>
<pre><code>\sizedrangedcode{\ssmall}{3}{100}{\ecl/tmethod/UseRandomInputStream.java}
</code></pre>
</section><section>
<h2 id="template-method-esempio-bankaccount">Template Method: esempio <code>BankAccount</code></h2>
<pre><code>\sizedrangedcode{\ssmall}{3}{100}{\ecl/tmethod/BankAccount.java}
</code></pre>
</section><section>
<h2 id="template-method-esempio-con-i-metodi-default">Template Method: esempio con i metodi <code>default</code></h2>
<pre><code>\sizedrangedcode{\ssmall}{5}{100}{\ecllambda/interfaces/SimpleIterator.java}
\sizedrangedcode{\ssmall}{3}{100}{\ecllambda/interfaces/UseSimpleIterator.java}
</code></pre>
</section><section>
<h2 id="strategy-comportamentale-su-oggetti">Strategy: comportamentale, su oggetti</h2>
<h3 id="intentomotivazione-2">Intento/motivazione</h3>
<pre><code>Definisce una famiglia di algoritmi, e li rende interscambiabili, ossia usabili in modo trasparente dai loro clienti
</code></pre>
<h3 id="esempi-2">Esempi</h3>
<ul>
<li>Strategia di disposizione di componenti in una GUI (<code>LayoutManager</code>)</li>
<li>Strategie di confronto fra due elementi per sorting (<code>Comparable</code>)</li>
<li>Strategie di <code>map</code>, <code>filter</code>, etc.. negli <code>Stream</code></li>
</ul>
<h3 id="soluzione-2">Soluzione</h3>
<ul>
<li>Gli algoritmi sono realizzati tramite specializzazioni di una classe/interfaccia base</li>
<li>Ai clienti passo un oggetto (di una specializzazione) della classe base</li>
<li>Se la strategia è funzionale si usano facilmente le lambda (e viceversa)</li>
<li>$\Rightarrow$ <em><strong>È probabilmente uno dei pattern più importanti (assieme al Factory Methods)</strong></em></li>
</ul>
</section><section>
<h2 id="strategy-uml">Strategy: UML</h2>
<pre><code>![](img/strategy.jpg)
</code></pre>
</section><section>
<h2 id="strategy-sorting-con-comparatori">Strategy: Sorting con comparatori</h2>
<pre><code>\sizedrangedcode{\ssmall}{5}{100}{\ecl/strategy/UseComparator.java}
</code></pre>
</section><section>
<h2 id="strategy-caso-del-bankaccount">Strategy: Caso del BankAccount</h2>
<pre><code>\sizedrangedcode{\ssmall}{3}{100}{\ecl/strategy/BankOperationFees.java}
\sizedrangedcode{\ssmall}{3}{100}{\ecl/strategy/StandardBankOperationFees.java}
</code></pre>
</section><section>
<h2 id="strategy-caso-del-bankaccount-1">Strategy: Caso del BankAccount</h2>
<pre><code>\sizedrangedcode{\ssmall}{3}{100}{\ecl/strategy/BankAccount.java}
</code></pre>
</section><section>
<h2 id="strategy-vs-template-method">Strategy vs Template Method</h2>
<h3 id="in-comune">In comune</h3>
<ul>
<li>Entrambi li si ottengono dall’esigenza di scorporare da una classe la gestione di una strategia o specializzazione</li>
<li>Entrambi richiedono un behaviour aggiuntivo da realizzare</li>
</ul>
<h3 id="differenze">Differenze</h3>
<ul>
<li>Strategy è più flessibile, perché gli oggetti che rappresentano la specializzazione sono liberi dal dover estendere una certa classe, e quindi sono più facilmente riusabili (p.e. un <code>Comparator</code> è usabile con collection diverse)</li>
<li>Template Method si integra con il subtyping, e quindi va usato quando a strategie specializzate devono corrispondere classi specializzate</li>
</ul>
<h3 id="altre-note">Altre note</h3>
<ul>
<li>Negli <code>InputStream</code> le limitazioni del Template Method sono mitigate dal Decorator</li>
<li>Con le lambda, l’approccio a Strategy diventa più naturale</li>
<li>Valutare di usare il Template Method insieme a Strategy, ossia per definire gerarchie di strategie</li>
</ul>
</section><section>
</section><section>
<h2 id="pattern-strategy">Pattern Strategy</h2>
</section>

  


</div>
      

    </div>
<script type="text/javascript" src="/reveal-hugo/object-assign.js"></script>

<a href="/reveal-js/dist/print/" id="print-location" style="display: none;"></a>

<script type="application/json" id="reveal-hugo-site-params">{"custom_theme":"custom-theme.scss","custom_theme_compile":true,"custom_theme_options":{"enablesourcemap":true,"targetpath":"css/custom-theme.css"},"height":"900","highlight_theme":"default","history":true,"mermaid":[{"startOnLoad":false}],"slide_number":true,"theme":"white","transition":"slide","transition_speed":"fast","width":"1440"}</script>
<script type="application/json" id="reveal-hugo-page-params">null</script>

<script src="/reveal-js/dist/reveal.js"></script>


  
  
  <script type="text/javascript" src="/reveal-js/plugin/markdown/markdown.js"></script>
  
  <script type="text/javascript" src="/reveal-js/plugin/highlight/highlight.js"></script>
  
  <script type="text/javascript" src="/reveal-js/plugin/zoom/zoom.js"></script>
  
  <script type="text/javascript" src="/reveal-js/plugin/notes/notes.js"></script>
  
  
  <script type="text/javascript" src="/reveal-js/plugin/notes/notes.js"></script>




<script type="text/javascript">
  
  
  function camelize(map) {
    if (map) {
      Object.keys(map).forEach(function(k) {
        newK = k.replace(/(\_\w)/g, function(m) { return m[1].toUpperCase() });
        if (newK != k) {
          map[newK] = map[k];
          delete map[k];
        }
      });
    }
    return map;
  }
  
  var revealHugoDefaults = { center: true, controls: true, history: true, progress: true, transition: "slide" };

  var revealHugoPlugins = { 
    plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealZoom ]
   };
  var revealHugoSiteParams = JSON.parse(document.getElementById('reveal-hugo-site-params').innerHTML);
  var revealHugoPageParams = JSON.parse(document.getElementById('reveal-hugo-page-params').innerHTML);
  
  var options = Object.assign({},
    camelize(revealHugoDefaults),
    camelize(revealHugoSiteParams),
    camelize(revealHugoPageParams),
    camelize(revealHugoPlugins));
  Reveal.initialize(options);
</script>








  <script src="https://cdn.jsdelivr.net/npm/mermaid@9.1.6/dist/mermaid.min.js"></script>
  <script>
    mermaid.initialize({"startOnLoad":false});

    let render = (event) => {
      let mermaidElems = event.currentSlide.querySelectorAll('.mermaid');
      if (!mermaidElems.length){
          return
      }
      mermaidElems.forEach(mermaidElem => {
          let processed = mermaidElem.getAttribute('data-processed');
          if (!processed){
              
              mermaid.init(undefined, mermaidElem);
          }
      });
    };
    Reveal.addEventListener('slidechanged', render);
    Reveal.addEventListener('ready', render);
  </script>

    <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      }
    };
</script>

<script type="text/javascript" id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>

    
  

</body></html>